/**
 * Copyright (C) 2015 Deepin Technology Co., Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 **/
package main

var __GLOBAL_TEMPLATE_GoLang = `
package {{PkgName}}
import "pkg.deepin.io/lib/dbus"
import "fmt"
import "sync"

var __conn *dbus.Conn = nil
var __connLock sync.Mutex

var __ruleCounter map[string]int = nil
var __ruleCounterLock sync.Mutex

func getBus() *dbus.Conn {
	__connLock.Lock()
	defer __connLock.Unlock()
	if __conn == nil {
		var err error
		__conn, err = dbus.{{BusType}}Bus()
		if err != nil {
			panic(err)
		}
	}
	return __conn
}

func getRuleCounter() map[string]int {
	__ruleCounterLock.Lock()
	defer __ruleCounterLock.Unlock()
	if __ruleCounter == nil {
		__ruleCounter = make(map[string]int)
	}
	return __ruleCounter
}

func dbusCall(method string, flags dbus.Flags, args ...interface{}) (err error) {
	err = getBus().BusObject().Call(method, flags, args...).Err
	if err != nil {
		fmt.Println(err)
	}
	return
}

func dbusAddMatch(rule string) (err error) {
	ruleCounter := getRuleCounter()

	__ruleCounterLock.Lock()
	defer __ruleCounterLock.Unlock()
	if _, ok := ruleCounter[rule]; !ok {
		err = dbusCall("org.freedesktop.DBus.AddMatch", 0, rule)
	}
	ruleCounter[rule]++
	return
}

func dbusRemoveMatch(rule string) (err error) {
	ruleCounter := getRuleCounter()

	__ruleCounterLock.Lock()
	defer __ruleCounterLock.Unlock()
	if _, ok := ruleCounter[rule]; !ok {
		return
	}
	ruleCounter[rule]--
	if ruleCounter[rule] == 0 {
		delete(ruleCounter, rule)
		err = dbusCall("org.freedesktop.DBus.RemoveMatch", 0, rule)
	}
	return
}
`

var __IFC_TEMPLATE_INIT_GoLang = `/*This file is automatically generated by pkg.deepin.io/dbus-generator. Don't edit it*/
package {{PkgName}}
import "pkg.deepin.io/lib/dbus"
import "pkg.deepin.io/lib/dbus/property"
import "reflect"
import "sync"
import "runtime"
import "fmt"
import "errors"
/*prevent compile error*/
var _ = fmt.Println
var _ = runtime.SetFinalizer
var _ = sync.NewCond
var _ = reflect.TypeOf
var _ = property.BaseObserver{}
`

var __IFC_TEMPLATE_GoLang = `
type {{ExportName}} struct {
	Path dbus.ObjectPath
	DestName string
	core *dbus.Object
{{if or .Properties .Signals}}
	signals map[<-chan *dbus.Signal]struct{}
	signalsLocker sync.Mutex
{{end}}
	{{range .Properties}}
	{{.Name}} *dbusProperty{{ExportName}}{{.Name}}{{end}}
}
{{if or .Properties .Signals}}
func ({{OBJ_NAME}} *{{ExportName}}) _createSignalChan() <-chan *dbus.Signal {
	{{OBJ_NAME}}.signalsLocker.Lock()
	ch := getBus().Signal()
	{{OBJ_NAME}}.signals[ch] = struct{}{}
	{{OBJ_NAME}}.signalsLocker.Unlock()
	return ch
}
func ({{OBJ_NAME}} *{{ExportName}}) _deleteSignalChan(ch <-chan *dbus.Signal) {
	{{OBJ_NAME}}.signalsLocker.Lock()
	delete({{OBJ_NAME}}.signals, ch)
	getBus().DetachSignal(ch)
	{{OBJ_NAME}}.signalsLocker.Unlock()
}
func Destroy{{ExportName}}(obj *{{ExportName}}) {
	obj.signalsLocker.Lock()
	defer obj.signalsLocker.Unlock()
	if obj.signals == nil {
		return
	}
	for ch, _ := range obj.signals {
		getBus().DetachSignal(ch)
	}
	obj.signals = nil

	runtime.SetFinalizer(obj, nil)

	dbusRemoveMatch("type='signal',path='"+string(obj.Path)+"',interface='org.freedesktop.DBus.Properties',sender='"+obj.DestName+"',member='PropertiesChanged'")
	dbusRemoveMatch("type='signal',path='"+string(obj.Path)+"',interface='{{IfcName}}',sender='"+obj.DestName+"',member='PropertiesChanged'")
{{range .Signals}}
	dbusRemoveMatch("type='signal',path='"+string({{OBJ_NAME}}.Path)+"',interface='{{IfcName}}',sender='"+{{OBJ_NAME}}.DestName+"',member='{{.Name}}'")
{{end}}
	{{range .Properties}}
	obj.{{.Name}}.Reset(){{end}}
}
{{end}}

{{$obj_name := .Name}}
{{range .Methods }}
func ({{OBJ_NAME}} *{{ExportName }}) {{Normalize .Name}} ({{GetParamterInsProto .Args}}) ({{GetParamterOutsProto .Args}} {{with GetParamterOuts .Args}},{{end}}_err error) {
	_err = {{OBJ_NAME}}.core.Call("{{$obj_name}}.{{.Name}}", 0{{GetParamterNames .Args}}).Store({{GetParamterOuts .Args}})
	if _err != nil {
		fmt.Println(_err)
	}
	return
}
{{end}}

{{range .Signals}}
func ({{OBJ_NAME}} *{{ExportName}}) Connect{{.Name}}(callback func({{GetParamterOutsProto .Args}})) func() {
	sigChan := {{OBJ_NAME}}._createSignalChan()
	go func() {
		for v := range(sigChan) {
			if v.Path != {{OBJ_NAME}}.Path || v.Name != "{{IfcName}}.{{.Name}}" || {{len .Args}} != len(v.Body) {
				continue
			}
			{{range $index, $arg := .Args}}if reflect.TypeOf(v.Body[{{ $index }}]) != reflect.TypeOf((*{{TypeFor $arg.Type}})(nil)).Elem() {
				continue
			}
			{{end}}

			callback({{range $index, $arg := .Args}}{{if $index}},{{end}}v.Body[{{$index}}].({{TypeFor $arg.Type}}){{end}})
		}
	}()
	return func() {
		{{OBJ_NAME}}._deleteSignalChan(sigChan)
	}
}
{{end}}

{{range .Properties}}
type dbusProperty{{ExportName}}{{.Name}} struct{
	*property.BaseObserver
	core *dbus.Object
}
{{if PropWritable .}}func (this *dbusProperty{{ExportName}}{{.Name}}) SetValue(v interface{}/*{{TypeFor .Type}}*/) {
	if reflect.TypeOf(v) == reflect.TypeOf((*{{TypeFor .Type}})(nil)).Elem() {
		this.core.Call("org.freedesktop.DBus.Properties.Set", 0, "{{IfcName}}", "{{.Name}}", dbus.MakeVariant(v))
	} else {
		fmt.Println("The property {{.Name}} of {{IfcName}} is an {{TypeFor .Type}} but Set with an ", reflect.TypeOf(v))
	}
}
func (this *dbusProperty{{ExportName}}{{.Name}}) Set(v {{TypeFor .Type}}) {
	this.SetValue(v)
}{{else}}
func (this *dbusProperty{{ExportName}}{{.Name}}) SetValue(notwritable interface{}) {
	fmt.Println("{{IfcName}}.{{.Name}} is not writable")
}{{end}}
{{ $convert := TryConvertObjectPath . }}
func (this *dbusProperty{{ExportName}}{{.Name}}) Get() {{GetObjectPathType .}} {
	v, _ := this.GetValue()
	return v.({{GetObjectPathType .}})
}
func (this *dbusProperty{{ExportName}}{{.Name}}) GetValue() (interface{} /*{{GetObjectPathType .}}*/, error) {
	var r dbus.Variant
	err := this.core.Call("org.freedesktop.DBus.Properties.Get", 0, "{{IfcName}}", "{{.Name}}").Store(&r)
	if err == nil && r.Signature().String() == "{{.Type}}" { {{ if $convert }}
		before := r.Value().({{TypeFor .Type}})
		{{$convert}}
		return after{{else}}
		return r.Value().({{TypeFor .Type}}){{end}}, nil
	}
	return *new({{TypeFor .Type}}), err
}
func (this *dbusProperty{{ExportName}}{{.Name}}) GetType() reflect.Type {
	return reflect.TypeOf((*{{TypeFor .Type}})(nil)).Elem()
}
{{end}}

func New{{ExportName}}(destName string, path dbus.ObjectPath) (*{{ExportName}}, error) {
	if !path.IsValid() {
		return nil, errors.New("The path of '" + string(path) + "' is invalid.")
	}

	core := getBus().Object(destName, path)

	obj := &{{ExportName}}{Path:path, DestName:destName, core:core{{if or .Signals .Properties}},signals:make(map[<-chan *dbus.Signal]struct{}){{end}}}
	{{range .Properties}}
	obj.{{.Name}} = &dbusProperty{{ExportName}}{{.Name}}{&property.BaseObserver{}, core}{{end}}
{{with .Properties}}
	dbusAddMatch("type='signal',path='"+string(path)+"',interface='org.freedesktop.DBus.Properties',sender='"+destName+"',member='PropertiesChanged'")
	dbusAddMatch("type='signal',path='"+string(path)+"',interface='{{IfcName}}',sender='"+destName+"',member='PropertiesChanged'")
	sigChan := obj._createSignalChan()
	go func() {
		typeString := reflect.TypeOf("")
		typeKeyValues := reflect.TypeOf(map[string]dbus.Variant{})
		typeArrayValues := reflect.TypeOf([]string{})
		for v := range(sigChan) {
			if v.Name == "org.freedesktop.DBus.Properties.PropertiesChanged" &&
				len(v.Body) == 3 &&
				reflect.TypeOf(v.Body[0]) == typeString &&
				reflect.TypeOf(v.Body[1]) == typeKeyValues &&
				reflect.TypeOf(v.Body[2]) == typeArrayValues &&
				v.Body[0].(string) == "{{IfcName}}" {
				props := v.Body[1].(map[string]dbus.Variant)
				for key, _ := range props {
					if false { {{range .}}
					} else if key == "{{.Name}}" {
						obj.{{.Name}}.Notify()
					{{end}} }
				}
			} else if v.Name == "{{IfcName}}.PropertiesChanged" && len(v.Body) == 1 && reflect.TypeOf(v.Body[0]) == typeKeyValues {
				for key, _ := range v.Body[0].(map[string]dbus.Variant) {
					if false { {{range .}}
					} else if key == "{{.Name}}" {
						obj.{{.Name}}.Notify()
					{{end}} }
				}
			}
		}
	}()
{{end}}
{{range .Signals}}
	dbusAddMatch("type='signal',path='"+string({{OBJ_NAME}}.Path)+"',interface='{{IfcName}}',sender='"+{{OBJ_NAME}}.DestName+"',member='{{.Name}}'")
{{end}}
{{if or .Properties .Signals}}runtime.SetFinalizer(obj, func(_obj *{{ExportName}}) { Destroy{{ExportName}}(_obj) }){{end}}
	return obj, nil
}

`

var __TEST_TEMPLATE = `/*This file is auto generate by pkg.deepin.io/dbus-generator. Don't edit it*/
package {{PkgName}}
import "testing"
{{range .Methods}}
func Test{{ObjName}}Method{{Normalize .Name}} (t *testing.T) {
	{{/*
	rnd := rand.New(rand.NewSource(99))
	r := Get{{ObjName}}("{{TestPath}}").{{.Name}}({{.Args}})
--*/}}

}
{{end}}

{{range .Properties}}
func Test{{ObjName}}Property{{.Name}} (t *testing.T) {
	t.Log("Get the property {{.Name}} of object {{ObjName}} ===> ",
		Get{{ObjName}}("{{TestPath}}").Get{{.Name}}())
}
{{end}}

{{range .Signals}}
func Test{{ObjName}}Signal{{.Name}} (t *testing.T) {
}
{{end}}
`
